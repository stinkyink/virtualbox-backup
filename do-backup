#!/usr/bin/env ruby

require 'csv'
require 'fileutils'
require 'tmpdir'

require 'bundler/setup'
require 'fog'

trap :INT, :EXIT

SCRIPT_DIR = File.dirname(__FILE__)
CONFIG_FILE = SCRIPT_DIR + '/config.yaml'

CONFIG = YAML.load_file(CONFIG_FILE)

OUT_DIR = CONFIG['local']['out-dir']
VERBOSE = CONFIG['verbose']

COMMANDS = CONFIG['local']['commands']
VBOX_MANAGE = COMMANDS['vbox-manage']
LVM = COMMANDS['lvm']
MOUNT = COMMANDS['mount']
UMOUNT = COMMANDS['umount']

require_relative 'lib/helpers'
require_relative 'lib/offsite_backup'
require_relative 'lib/virtual_hard_disk'
require_relative 'lib/virtual_machine'
require_relative 'lib/virtual_machine_backup'

def print_usage_and_exit!(code = 1)
  STDOUT.puts <<-OUT
Usage: #{File.basename(__FILE__)} [options]

Options:
  -h, --help        Show this help
      --no-offsite  Don't perform off-site backup
  OUT
  exit
end

$do_offsite = true
if ARGV.length > 0
  ARGV.each do |arg|
    case arg
    when '-h', '--help'
      print_usage_and_exit!(0)
    when '--no-offsite'
      $do_offsite = false
    else
      STDERR.puts "ERROR: Unknown option: #{arg}"
      STDERR.puts
      print_usage_and_exit!
    end
  end
end

if not Dir.exists?(OUT_DIR)
  STDERR.puts "ERROR: Output directory does not exist: #{OUT_DIR}"
  exit!
end

virtual_machines = VirtualMachine.find(CONFIG['virtual-machines']['include'])
backups = virtual_machines.map {|vm| VirtualMachineBackup.new(vm) }

# Local Backup
backups.each(&:do_backup!)

# Offsite Backup
exit  if not $do_offsite
exclude_offsite_uuids =
  VirtualMachine.find(CONFIG['virtual-machines']['offsite-exclude']).
    map(&:uuid)
backups.each do |backup|
  next  if exclude_offsite_uuids.include?(backup.virtual_machine.uuid)
  if backup.error?
    STDERR.puts "WARNING: #{backup.virtual_machine}: Skipping offsite backup " +
                "due to previous errors."
    next
  end
  description =
    backup.time.strftime("%Y-%m-%d_%H:%M") + " #{backup.virtual_machine}"
  OffsiteBackup.new(backup.target_dir, description).push_offsite!
end
